#include <iostream>
#include<vector>
#include<queue>
#include<unordered_map>
using namespace std;
//2020年11月21日下午9:30:17
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        //思路，这？只能完成2笔，就挺吓人的，难道要分只完成一次和完成两次？我不懂了。
        //C++中如何申请三维数组？，可以转换为申请两个数组
        size_t m=prices.size();
        vector<vector<int>> dp1(m,vector<int>(2,0));
        vector<vector<int>> dp2(m,vector<int>(2,0));

        //如何初始化？
        dp1[0][1]=-prices[0];//表示第0天进行一次操作拥有股票
        dp2[0][1]=-prices[0];

        //dp1[i][0]表示进行一次交以且不持有股票，因为我们是在买入时计算了交易次数，所以这个状态表示第一次卖出
        //dp1[i][1]表示第i天进行一次交易，持有股票，那就是刚买入的时候
        for(size_t i=1;i<m;i++){
            dp1[i][0]=max(dp1[i-1][0],dp1[i-1][1]+prices[i]);//这里是第一次卖出
            dp1[i][1]=max(dp1[i-1][1],-prices[i]);//这里是第一次买入
            dp2[i][0]=max(dp2[i-1][0],dp2[i-1][1]+prices[i]);//用dp2表示的是完成本次交易
            dp2[i][1]=max(dp2[i-1][1],dp1[i-1][0]-prices[i]);
//            cout<<dp1[i][0]<<" "<<dp1[i][1]<<" "<<dp2[i][0]<<" "<<dp2[i][1]<<endl;
        }
        return dp2[m-1][0];
    }
};
/*
 * 1.从这道题开始追求bugfree，要在自己确认过没有低级语法错误、并且手动运行过样例之后再提交，不应该让
 *   编译器去做检查，而应该自己手动地检查。
 * 2.[3,3,5,0,0,3,1,4]，6，却输出了4，手动运行一下，先更新dp1和dp2有什么区别吗？为什么结果是4？
 *   i=1:
 *   	dp1[1][0]=max(dp1[0][0],dp1[0][1]+prices[1])=max(0,-3+3)=0
 *   	dp1[1][1]=max(dp1[0][1],dp1[0][0]-prices[1])=max(-3,0-3)=-3
 *   	dp2[1][0]=max(dp2[0][0],dp1[0][1]+prices[1])=max(0,-3+3)=0
 *   	dp2[1][1]=max()
 * */

//12-28
/*
 * 1.再次复习我就完全懵了。
 * 思路：设置两个状态：第0个下标表示天数，第1个下标表示状态，第2个下标表示完成几次交易。
dp[i][0][0]在第i天没有股票完成0笔交易
dp[i][0][1]在第i天没有股票完成1笔交易
dp[i][1][0]第i天持有股票完成0笔交易
dp[i][0][0]=dp[i-1][0][0]
dp[i][1][0]=-prices[i]
dp[i][0][1]=dp[i][1][0]+prices[i]
dp[i][1][1]=dp[i-1][0][1]-prices[i]
dp[i][0][2]=dp[i-1][]
我发现在买入的时候就购买次数k+1就可以避免出现dp[i][0][1]完成0次交易但是拥有股票这样的式子了？
比如说dp[i][1][0]那就可能是当时刚卖出。dp[i][1][1]当时刚买入。
也就是买入的时候计算交易次数。但是难道在卖出的时候再计算交易次数难道不行吗？我感觉要想通这个地方。

2.上面是我思路完全不通的碎碎念啊。这里状态0表示当天卖出，状态1表示当天买入，并且在买入时就计算交易次数！
  使得交易次数+1.
 * */

//3-9复习


int main(){
	Solution s;
	vector<int> p={1,2,3,4,5};
	cout<<s.maxProfit(p);
    return 0;
}
